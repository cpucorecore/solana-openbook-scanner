// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package openbook_v2

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "OpenbookV2"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	// Create a [`Market`](crate::state::Market) for a given token pair.
	Instruction_CreateMarket = ag_binary.TypeID([8]byte{103, 226, 97, 235, 200, 188, 251, 254})

	// Close a [`Market`](crate::state::Market) (only
	// [`close_market_admin`](crate::state::Market::close_market_admin)).
	Instruction_CloseMarket = ag_binary.TypeID([8]byte{88, 154, 248, 186, 48, 14, 123, 244})

	// Create an [`OpenOrdersIndexer`](crate::state::OpenOrdersIndexer) account.
	Instruction_CreateOpenOrdersIndexer = ag_binary.TypeID([8]byte{64, 64, 153, 255, 217, 71, 249, 133})

	// Close an [`OpenOrdersIndexer`](crate::state::OpenOrdersIndexer) account.
	Instruction_CloseOpenOrdersIndexer = ag_binary.TypeID([8]byte{103, 249, 229, 231, 247, 253, 197, 136})

	// Create an [`OpenOrdersAccount`](crate::state::OpenOrdersAccount).
	Instruction_CreateOpenOrdersAccount = ag_binary.TypeID([8]byte{204, 181, 175, 222, 40, 125, 188, 71})

	// Close an [`OpenOrdersAccount`](crate::state::OpenOrdersAccount).
	Instruction_CloseOpenOrdersAccount = ag_binary.TypeID([8]byte{176, 74, 115, 210, 54, 179, 91, 103})

	// Place an order.
	//
	// Different types of orders have different effects on the order book,
	// as described in [`PlaceOrderType`](crate::state::PlaceOrderType).
	//
	// `price_lots` refers to the price in lots: the number of quote lots
	// per base lot. It is ignored for `PlaceOrderType::Market` orders.
	//
	// `expiry_timestamp` is a unix timestamp for when this order should
	// expire. If 0 is passed in, the order will never expire. If the time
	// is in the past, the instruction is skipped. Timestamps in the future
	// are reduced to now + 65,535s.
	//
	// `limit` determines the maximum number of orders from the book to fill,
	// and can be used to limit CU spent. When the limit is reached, processing
	// stops and the instruction succeeds.
	Instruction_PlaceOrder = ag_binary.TypeID([8]byte{51, 194, 155, 175, 109, 130, 96, 106})

	// Edit an order.
	Instruction_EditOrder = ag_binary.TypeID([8]byte{254, 208, 118, 29, 173, 248, 200, 70})

	// Edit an order pegged.
	Instruction_EditOrderPegged = ag_binary.TypeID([8]byte{62, 187, 125, 69, 26, 221, 157, 133})

	// Place multiple orders
	Instruction_PlaceOrders = ag_binary.TypeID([8]byte{60, 63, 50, 123, 12, 197, 60, 190})

	// Cancel orders and place multiple orders.
	Instruction_CancelAllAndPlaceOrders = ag_binary.TypeID([8]byte{128, 155, 222, 60, 186, 40, 225, 50})

	// Place an oracle-peg order.
	Instruction_PlaceOrderPegged = ag_binary.TypeID([8]byte{141, 185, 251, 63, 74, 85, 210, 145})

	// Place an order that shall take existing liquidity off of the book, not
	// add a new order off the book.
	//
	// This type of order allows for instant token settlement for the taker.
	Instruction_PlaceTakeOrder = ag_binary.TypeID([8]byte{3, 44, 71, 3, 26, 199, 203, 85})

	// Process up to `limit` [events](crate::state::AnyEvent).
	//
	// When a user places a 'take' order, they do not know beforehand which
	// market maker will have placed the 'make' order that they get executed
	// against. This prevents them from passing in a market maker's
	// [`OpenOrdersAccount`](crate::state::OpenOrdersAccount), which is needed
	// to credit/debit the relevant tokens to/from the maker. As such, Openbook
	// uses a 'crank' system, where `place_order` only emits events, and
	// `consume_events` handles token settlement.
	//
	// Currently, there are two types of events: [`FillEvent`](crate::state::FillEvent)s
	// and [`OutEvent`](crate::state::OutEvent)s.
	//
	// A `FillEvent` is emitted when an order is filled, and it is handled by
	// debiting whatever the taker is selling from the taker and crediting
	// it to the maker, and debiting whatever the taker is buying from the
	// maker and crediting it to the taker. Note that *no tokens are moved*,
	// these are just debits and credits to each party's [`Position`](crate::state::Position).
	//
	// An `OutEvent` is emitted when a limit order needs to be removed from
	// the book during a `place_order` invocation, and it is handled by
	// crediting whatever the maker would have sold (quote token in a bid,
	// base token in an ask) back to the maker.
	Instruction_ConsumeEvents = ag_binary.TypeID([8]byte{221, 145, 177, 52, 31, 47, 63, 201})

	// Process the [events](crate::state::AnyEvent) at the given positions.
	Instruction_ConsumeGivenEvents = ag_binary.TypeID([8]byte{209, 227, 54, 4, 109, 172, 41, 71})

	// Cancel an order by its `order_id`.
	//
	// Note that this doesn't emit an [`OutEvent`](crate::state::OutEvent) because a
	// maker knows that they will be passing in their own [`OpenOrdersAccount`](crate::state::OpenOrdersAccount).
	Instruction_CancelOrder = ag_binary.TypeID([8]byte{95, 129, 237, 240, 8, 49, 223, 132})

	// Cancel an order by its `client_order_id`.
	//
	// Note that this doesn't emit an [`OutEvent`](crate::state::OutEvent) because a
	// maker knows that they will be passing in their own [`OpenOrdersAccount`](crate::state::OpenOrdersAccount).
	Instruction_CancelOrderByClientOrderId = ag_binary.TypeID([8]byte{115, 178, 201, 8, 175, 183, 123, 119})

	// Cancel up to `limit` orders, optionally filtering by side
	Instruction_CancelAllOrders = ag_binary.TypeID([8]byte{196, 83, 243, 171, 17, 100, 160, 143})

	// Deposit a certain amount of `base` and `quote` lamports into one's
	// [`Position`](crate::state::Position).
	//
	// Makers might wish to `deposit`, rather than have actual tokens moved for
	// each trade, in order to reduce CUs.
	Instruction_Deposit = ag_binary.TypeID([8]byte{242, 35, 198, 137, 82, 225, 242, 182})

	// Refill a certain amount of `base` and `quote` lamports. The amount being passed is the
	// total lamports that the [`Position`](crate::state::Position) will have.
	//
	// Makers might wish to `refill`, rather than have actual tokens moved for
	// each trade, in order to reduce CUs.
	Instruction_Refill = ag_binary.TypeID([8]byte{128, 207, 142, 11, 54, 232, 38, 201})

	// Withdraw any available tokens.
	Instruction_SettleFunds = ag_binary.TypeID([8]byte{238, 64, 163, 96, 75, 171, 16, 33})

	// Withdraw any available tokens when the market is expired (only
	// [`close_market_admin`](crate::state::Market::close_market_admin)).
	Instruction_SettleFundsExpired = ag_binary.TypeID([8]byte{107, 18, 56, 69, 228, 56, 55, 164})

	// Sweep fees, as a [`Market`](crate::state::Market)'s admin.
	Instruction_SweepFees = ag_binary.TypeID([8]byte{175, 225, 98, 71, 118, 66, 34, 148})

	// Update the [`delegate`](crate::state::OpenOrdersAccount::delegate) of an open orders account.
	Instruction_SetDelegate = ag_binary.TypeID([8]byte{242, 30, 46, 76, 108, 235, 128, 181})

	// Set market to expired before pruning orders and closing the market (only
	// [`close_market_admin`](crate::state::Market::close_market_admin)).
	Instruction_SetMarketExpired = ag_binary.TypeID([8]byte{219, 82, 219, 236, 60, 115, 197, 64})

	// Remove orders from the book when the market is expired (only
	// [`close_market_admin`](crate::state::Market::close_market_admin)).
	Instruction_PruneOrders = ag_binary.TypeID([8]byte{27, 213, 159, 191, 12, 116, 112, 121})

	Instruction_StubOracleCreate = ag_binary.TypeID([8]byte{172, 63, 101, 83, 141, 76, 199, 216})

	Instruction_StubOracleClose = ag_binary.TypeID([8]byte{92, 137, 45, 3, 45, 60, 117, 224})

	Instruction_StubOracleSet = ag_binary.TypeID([8]byte{109, 198, 79, 121, 65, 202, 161, 142})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_CreateMarket:
		return "CreateMarket"
	case Instruction_CloseMarket:
		return "CloseMarket"
	case Instruction_CreateOpenOrdersIndexer:
		return "CreateOpenOrdersIndexer"
	case Instruction_CloseOpenOrdersIndexer:
		return "CloseOpenOrdersIndexer"
	case Instruction_CreateOpenOrdersAccount:
		return "CreateOpenOrdersAccount"
	case Instruction_CloseOpenOrdersAccount:
		return "CloseOpenOrdersAccount"
	case Instruction_PlaceOrder:
		return "PlaceOrder"
	case Instruction_EditOrder:
		return "EditOrder"
	case Instruction_EditOrderPegged:
		return "EditOrderPegged"
	case Instruction_PlaceOrders:
		return "PlaceOrders"
	case Instruction_CancelAllAndPlaceOrders:
		return "CancelAllAndPlaceOrders"
	case Instruction_PlaceOrderPegged:
		return "PlaceOrderPegged"
	case Instruction_PlaceTakeOrder:
		return "PlaceTakeOrder"
	case Instruction_ConsumeEvents:
		return "ConsumeEvents"
	case Instruction_ConsumeGivenEvents:
		return "ConsumeGivenEvents"
	case Instruction_CancelOrder:
		return "CancelOrder"
	case Instruction_CancelOrderByClientOrderId:
		return "CancelOrderByClientOrderId"
	case Instruction_CancelAllOrders:
		return "CancelAllOrders"
	case Instruction_Deposit:
		return "Deposit"
	case Instruction_Refill:
		return "Refill"
	case Instruction_SettleFunds:
		return "SettleFunds"
	case Instruction_SettleFundsExpired:
		return "SettleFundsExpired"
	case Instruction_SweepFees:
		return "SweepFees"
	case Instruction_SetDelegate:
		return "SetDelegate"
	case Instruction_SetMarketExpired:
		return "SetMarketExpired"
	case Instruction_PruneOrders:
		return "PruneOrders"
	case Instruction_StubOracleCreate:
		return "StubOracleCreate"
	case Instruction_StubOracleClose:
		return "StubOracleClose"
	case Instruction_StubOracleSet:
		return "StubOracleSet"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"create_market", (*CreateMarket)(nil),
		},
		{
			"close_market", (*CloseMarket)(nil),
		},
		{
			"create_open_orders_indexer", (*CreateOpenOrdersIndexer)(nil),
		},
		{
			"close_open_orders_indexer", (*CloseOpenOrdersIndexer)(nil),
		},
		{
			"create_open_orders_account", (*CreateOpenOrdersAccount)(nil),
		},
		{
			"close_open_orders_account", (*CloseOpenOrdersAccount)(nil),
		},
		{
			"place_order", (*PlaceOrder)(nil),
		},
		{
			"edit_order", (*EditOrder)(nil),
		},
		{
			"edit_order_pegged", (*EditOrderPegged)(nil),
		},
		{
			"place_orders", (*PlaceOrders)(nil),
		},
		{
			"cancel_all_and_place_orders", (*CancelAllAndPlaceOrders)(nil),
		},
		{
			"place_order_pegged", (*PlaceOrderPegged)(nil),
		},
		{
			"place_take_order", (*PlaceTakeOrder)(nil),
		},
		{
			"consume_events", (*ConsumeEvents)(nil),
		},
		{
			"consume_given_events", (*ConsumeGivenEvents)(nil),
		},
		{
			"cancel_order", (*CancelOrder)(nil),
		},
		{
			"cancel_order_by_client_order_id", (*CancelOrderByClientOrderId)(nil),
		},
		{
			"cancel_all_orders", (*CancelAllOrders)(nil),
		},
		{
			"deposit", (*Deposit)(nil),
		},
		{
			"refill", (*Refill)(nil),
		},
		{
			"settle_funds", (*SettleFunds)(nil),
		},
		{
			"settle_funds_expired", (*SettleFundsExpired)(nil),
		},
		{
			"sweep_fees", (*SweepFees)(nil),
		},
		{
			"set_delegate", (*SetDelegate)(nil),
		},
		{
			"set_market_expired", (*SetMarketExpired)(nil),
		},
		{
			"prune_orders", (*PruneOrders)(nil),
		},
		{
			"stub_oracle_create", (*StubOracleCreate)(nil),
		},
		{
			"stub_oracle_close", (*StubOracleClose)(nil),
		},
		{
			"stub_oracle_set", (*StubOracleSet)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
